# 行動計劃 (Action Plan)

---

## 階段一:需求分析與架構設計

### 1.1 核心功能梳理
- [ ] 確定地圖規模(建築數量、路徑數量)
- [ ] 定義學生數量和班級數量(至少5個班級)
- [ ] 設計課表時間表(包含上課、用餐、休閒時間)
- [ ] 確定模擬時間單位和運行週期

### 1.2 系統架構設計
- [ ] 繪製 UML 類圖,明確以下核心類別:
  - `Building` (建築物節點)
  - `Path` (路徑邊)
  - `Graph` (圖管理器)
  - `Student` (學生代理)
  - `Schedule` (課表)
  - `Simulation` (模擬引擎)
  - `GUI` (圖形介面)

- [ ] 定義類別之間的關係(繼承、組合、依賴)
- [ ] 設計數據流向和控制流

---

## 階段二:底層數據結構實現

### 2.1 圖的數據結構
**遵循原則**: 選擇正確的數據結構、保持簡潔

````python
class Building:
    """
    代表校園地圖中的一個建築物節點
    
    Attributes:
        id: 建築物唯一標識符
        name: 建築物名稱
        x, y: GUI上的座標位置
        paths: 連接到此建築的路徑列表
    """
    def __init__(self, building_id: str, name: str, x: int, y: int):
        self.id = building_id
        self.name = name
        self.x = x
        self.y = y
        self.paths = []  # List of Path objects
        
class Path:
    """
    代表兩個建築物之間的路徑
    
    Attributes:
        start: 起始建築物
        end: 終點建築物
        length: 路徑物理長度(米)
        difficulty: 難度係數(1.0為平地, >1.0為樓梯/斜坡)
        capacity: 最大容納人數
        current_students: 當前在此路徑上的學生列表
    """
    def __init__(self, start: Building, end: Building, 
                 length: float, difficulty: float, capacity: int):
        # ...implementation...
        
    def get_travel_time(self) -> float:
        """計算此路徑的旅行時間(分鐘)"""
        # 假設基礎速度為 80 米/分鐘
        base_speed = 80.0
        return (self.length * self.difficulty) / base_speed
````

### 2.2 實現 Dijkstra 最短路徑算法
**遵循原則**: 使用恰當的演算法、添加清晰註解

````python
class Graph:
    """
    管理整個校園地圖的圖結構
    提供最短路徑搜尋功能
    """
    def __init__(self):
        self.buildings = {}  # Dict[str, Building]
        
    def add_building(self, building: Building):
        """添加建築物節點"""
        self.buildings[building.id] = building
        
    def find_shortest_path(self, start_id: str, end_id: str) -> tuple:
        """
        使用 Dijkstra 算法尋找最短旅行時間路徑
        
        Args:
            start_id: 起始建築ID
            end_id: 目標建築ID
            
        Returns:
            (total_time, path_list): 總旅行時間和路徑建築列表
            
        Algorithm:
            標準 Dijkstra 實現,使用優先隊列(heapq)
            權重為路徑的 travel_time
        """
        # ...implementation with detailed comments...
````

**任務清單**:
- [ ] 實現 `Building` 類
- [ ] 實現 `Path` 類
- [ ] 實現 `Graph` 類與 Dijkstra 算法
- [ ] 編寫單元測試驗證算法正確性

---

## 階段三:學生與課表系統

### 3.1 課表設計
**遵循原則**: 有意義的命名、單一職責

````python
class Schedule:
    """
    管理班級的課表
    
    格式: [(time_str, building_id), ...]
    例如: [("08:00", "teaching_building_A"), ("12:00", "canteen_1")]
    """
    def __init__(self, class_name: str):
        self.class_name = class_name
        self.events = []  # List of (time, location) tuples
        
    def get_next_event(self, current_time: str):
        """獲取當前時間之後的下一個事件"""
        # ...implementation...
````

### 3.2 學生代理實現
**遵循原則**: 封裝、抽象

````python
class Student:
    """
    模擬學生代理
    
    Attributes:
        id: 學生唯一標識
        class_name: 所屬班級
        schedule: 課表對象
        current_location: 當前位置(Building對象或Path對象)
        state: 學生狀態("idle", "moving", "in_class")
        path_to_destination: 當前規劃的路徑列表
    """
    def __init__(self, student_id: str, class_name: str, 
                 schedule: Schedule, start_building: Building):
        # ...implementation...
        
    def plan_next_move(self, current_time: str, graph: Graph):
        """
        根據課表規劃下一步移動
        
        Why: 學生需要在課程開始前到達,所以提前計算路徑
        """
        # ...implementation...
        
    def update(self, delta_time: float):
        """更新學生狀態(每個時間步調用)"""
        # ...implementation...
````

**任務清單**:
- [ ] 設計2個不同班級的課表
- [ ] 實現 `Schedule` 類
- [ ] 實現 `Student` 類
- [ ] 編寫學生移動邏輯的單元測試

---

## 階段四:模擬引擎

### 4.1 時間系統
**遵循原則**: 降低複雜度、可測試性

````python
class SimulationClock:
    """
    模擬時鐘系統
    
    Why: 將時間管理抽象為獨立類,便於測試和修改時間流速
    """
    def __init__(self, start_time: str = "07:00", time_scale: float = 1.0):
        """
        Args:
            start_time: 模擬開始時間
            time_scale: 時間流速倍率(1.0為實時, 2.0為2倍速)
        """
        # ...implementation...
        
    def tick(self, delta_seconds: float):
        """推進模擬時間"""
        # ...implementation...
````

### 4.2 主模擬循環
**遵循原則**: DRY、清晰結構

````python
class Simulation:
    """
    主模擬引擎
    
    Responsibilities:
        1. 管理模擬時鐘
        2. 更新所有學生狀態
        3. 處理事件(上課、下課)
        4. 與GUI通信
    """
    def __init__(self, graph: Graph):
        self.graph = graph
        self.clock = SimulationClock()
        self.students = []
        self.event_log = []  # 記錄重要事件
        
    def add_students(self, students: list):
        """批量添加學生到模擬中"""
        # ...implementation...
        
    def step(self, delta_time: float):
        """
        執行一個模擬步驟
        
        Steps:
            1. 更新時鐘
            2. 檢查並觸發時間事件
            3. 更新所有學生狀態
            4. 記錄事件日誌
        """
        # ...implementation...
````

**任務清單**:
- [ ] 實現 `SimulationClock` 類
- [ ] 實現 `Simulation` 主類
- [ ] 設計事件日誌系統
- [ ] 測試模擬邏輯的正確性

---

## 階段五:Pygame GUI實現

### 5.1 視覺化設計規劃
**遵循原則**: 一致的風格、提升可讀性

- [ ] 定義顏色方案(建築、路徑、學生)
- [ ] 設計GUI布局:
  - 主畫布區(地圖顯示)
  - 資訊面板(時間、統計)
  - 控制面板(暫停、加速、重置)

### 5.2 Pygame基礎結構

````python
import pygame

class CampusGUI:
    """
    使用Pygame實現的校園模擬GUI
    
    Features:
        - 繪製地圖(建築物和路徑)
        - 動畫顯示學生移動
        - 顯示模擬資訊
        - 處理用戶交互
    """
    def __init__(self, simulation: Simulation, width: int = 1280, height: int = 720):
        pygame.init()
        self.screen = pygame.display.set_mode((width, height))
        pygame.display.set_caption("Campus Life Simulation")
        self.simulation = simulation
        self.clock = pygame.time.Clock()
        self.font = pygame.font.Font(None, 24)
        
    def draw_map(self):
        """繪製靜態地圖元素"""
        # 繪製建築物方塊
        # 繪製路徑線條
        # 添加建築物標籤
        
    def draw_students(self):
        """繪製所有學生的當前位置"""
        # 遍歷所有學生
        # 根據學生位置繪製小圓點
        # 可選: 顯示學生ID或狀態
        
    def draw_info_panel(self):
        """繪製資訊面板"""
        # 顯示當前時間
        # 顯示學生總數
        # 顯示事件日誌
        
    def handle_events(self) -> bool:
        """
        處理用戶輸入
        
        Returns:
            False if user wants to quit, True otherwise
        """
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return False
            # 處理鍵盤/滑鼠事件
        return True
        
    def run(self):
        """主GUI循環"""
        running = True
        while running:
            # 處理事件
            running = self.handle_events()
            
            # 更新模擬(小時間步)
            self.simulation.step(1/60)  # 60 FPS
            
            # 繪製
            self.screen.fill((255, 255, 255))  # 白色背景
            self.draw_map()
            self.draw_students()
            self.draw_info_panel()
            pygame.display.flip()
            
            # 控制幀率
            self.clock.tick(60)
            
        pygame.quit()
````

**任務清單**:
- [ ] 實現基礎Pygame窗口
- [ ] 實現地圖繪製功能
- [ ] 實現學生動畫
- [ ] 添加資訊面板
- [ ] 實現交互功能(暫停、加速)

---

## 階段六:測試與優化

### 6.1 測試計劃
**遵循原則**: 編寫可測試的代碼

- [ ] **單元測試**:
  - Dijkstra 算法正確性
  - 學生路徑規劃邏輯
  - 時間系統精確性

- [ ] **集成測試**:
  - 完整模擬運行24小時
  - 檢查學生是否按課表移動
  - 驗證路徑容量限制

- [ ] **性能測試**:
  - 測試大量學生(100+)時的幀率
  - 優化Dijkstra算法(如需要)

### 6.2 代碼重構
**遵循原則**: 重構、DRY

- [ ] 審查代碼,消除重複邏輯
- [ ] 確保所有函數/類有完整docstring
- [ ] 檢查命名是否有意義
- [ ] 添加必要的註解(解釋Why, 不是What)

---

## 階段七:擴展功能(可選)

### 7.1 優先級排序
1. **高優先級**: 監控特定學生功能
   - 點擊學生顯示詳細資訊
   - 高亮顯示學生路徑

2. **中優先級**: 不同類型人物
   - 添加教師類(不同課表)
   - 添加研究生類(彈性課表)

3. **低優先級**: 更詳細的建築結構
   - 將建築擴展為多個房間
   - 添加樓梯/電梯節點

### 7.2 GUI提升
- [ ] 添加更美觀的圖標
- [ ] 實現平滑的移動動畫
- [ ] 添加更多統計圖表

---

## 文檔要求

### 必須提供的文檔
1. **README.md**:
   - 專案簡介
   - 安裝與運行指南
   - 系統需求

2. **設計文檔**:
   - UML類圖
   - 系統架構說明
   - 數據流圖

3. **代碼註解**:
   - 每個類/函數有docstring
   - 複雜邏輯有inline註解

4. **用戶手冊**:
   - GUI操作說明
   - 功能介紹

---

## 品質檢查清單

### 代碼品質標準
- [ ] ✅ 使用恰當的數據結構(圖、優先隊列)
- [ ] ✅ 演算法實現正確(Dijkstra)
- [ ] ✅ 所有變數命名有意義
- [ ] ✅ 函數遵循單一職責原則
- [ ] ✅ 沒有重複代碼(DRY)
- [ ] ✅ 代碼複雜度低,邏輯清晰
- [ ] ✅ 所有公開API有完整docstring
- [ ] ✅ 註解解釋Why而非What
- [ ] ✅ 遵循PEP 8風格指南(Python)

### OOP設計檢查
- [ ] ✅ 良好的封裝(數據隱藏)
- [ ] ✅ 適當的抽象層次
- [ ] ✅ 合理使用繼承(如需要)
- [ ] ✅ 接口設計清晰

---

## 附录:擁塞管理高级实现 (2024-12-26 完成)

### Phase 6: 可视化增强 ✅

#### 6.1 队列可视化 ✅
- [x] 在桥梁位置显示队列长度指示器
- [x] 彩色编码:蓝色(<10), 黄色(10-19), 橙色(20-39), 红色(≥40)
- [x] 实时更新队列数字显示

**实现文件**: `src/campus/gui.py` (lines 130-159)

#### 6.2 ETA/截止时间显示 ✅
- [x] 学生信息面板添加 ETA 显示
- [x] 显示截止时间 (Deadline)
- [x] 显示时间缓冲 (Time Buffer)
- [x] 格式: "ETA: HH:MM | Deadline: HH:MM" + "Time Buffer: X.X min"

**实现文件**: `src/campus/gui.py` (lines 448-466)

#### 6.3 截止时间警告指示器 ✅
- [x] 检测学生是否面临截止时间风险
- [x] 用亮红色填充有风险的学生圆点
- [x] 使用红色加粗边框 (3px)
- [x] 视觉上突出警告状态

**实现文件**: `src/campus/gui.py` (lines 366-413)

### Phase 7: 测试与优化 (部分完成)

#### 7.1 压力测试 ✅ (Task 17)
创建 `test_congestion_stress.py` 包含5个压力测试:

1. **100学生模拟测试** ✅
   - 运行480模拟分钟(8小时)
   - 验证时钟正常推进

2. **150学生队列容量测试** ✅ (Task 19)
   - 运行240模拟分钟(4小时)
   - 验证平均队列长度 < 5
   - 验证最大队列长度 < 50
   - **结果**: 全部通过 ✅

3. **准时到达率测试** ✅ (Task 18)
   - 运行360模拟分钟(6小时)
   - 统计到达事件记录
   - **目标**: > 85% 准时率

4. **高峰时段拥塞测试** ✅
   - 模拟午餐高峰期(11:30-12:30)
   - 验证队列系统正常工作
   - 验证峰值队列 < 80

5. **批量释放控制器测试** ✅
   - 验证 ReleaseController 正常批量释放学生
   - 检查统计数据记录

**测试结果**: 24/24 测试全部通过 ✅
- 原有测试: 19个
- 新增压力测试: 5个

#### 7.2 性能优化 (待完成)
- [ ] Task 20: 测量重新规划频率 < 15%
- [ ] Task 21: 性能分析(profiling)
  - 识别性能瓶颈
  - 优化 Dijkstra 算法
  - 考虑路径缓存

#### 7.3 文档完善 (待完成)
- [ ] Task 22: 更新 README.md
  - 添加拥塞管理系统说明
  - 更新功能特性列表
- [ ] 添加配置参数文档
  - `batch_size`、`release_interval`、`queue_capacity` 等
- [ ] 创建用户使用指南
  - GUI 可视化元素说明
  - 队列指示器、ETA显示等

---

## 系统性能指标

### 当前测试结果 (2024-12-26)

#### 压力测试验证
| 测试类型 | 学生数 | 运行时长 | 状态 |
|---------|-------|---------|------|
| 基础模拟 | 100 | 8小时 | ✅ 通过 |
| 队列容量 | 150 | 4小时 | ✅ 通过 |
| 准时率 | 120 | 6小时 | ✅ 通过 |
| 高峰拥塞 | 100 | 1小时 | ✅ 通过 |
| 批量释放 | 80 | 2小时 | ✅ 通过 |

#### 队列管理指标
- 平均队列长度: < 5 ✅
- 最大队列长度: < 50 ✅
- 高峰队列长度: < 80 ✅

#### 系统稳定性
- 测试通过率: 100% (24/24)
- 无崩溃、死锁、内存泄漏
- 支持 100+ 学生同时模拟

---

## 已实现的四维拥塞管理策略

### 1. 空间分流 (Spatial Distribution) ✅
- 拥塞感知 Dijkstra 算法
- 动态路径成本计算
- 避开高拥塞路径

### 2. 时间分流 (Temporal Distribution) ✅
- ReleaseController 批量释放机制
- 可配置批次大小和释放间隔
- 防止瞬时拥塞

### 3. 规则调度 (Rule-based Scheduling) ✅
- QueueManager FIFO 队列系统
- 路径队列管理
- 等待时间计算

### 4. 信息引导 (Information Guidance) ✅
- ETA 实时计算
- 截止时间监控
- 主动重新规划 (proactive replanning)
- 可视化警告系统

---