# 路径成本分析文档

## 概述

本项目中，路径成本（Walking Cost）用于 **Dijkstra 最短路径算法**，帮助学生选择从起点到目的地的最优路径。成本的核心指标是 **旅行时间（Travel Time）**。

---

## 1. 核心数据结构

### 1.1 `Path` 类（路径边）

**文件位置**: `src/campus/graph.py` (第 30-58 行)

```python
@dataclass
class Path:
    """Represents a traversal edge between two buildings."""
    
    start: Building          # 起始建筑
    end: Building            # 终点建筑
    length: float            # 路径物理长度（米）
    difficulty: float = 1.0  # 难度系数（默认 1.0）
    capacity: Optional[int] = None  # 容量限制（可选）
    current_students: List[str] = field(default_factory=list)  # 当前使用者
```

#### 关键属性说明

| 属性 | 类型 | 说明 | 示例 |
|------|------|------|------|
| `length` | `float` | 路径的物理距离（米） | 80, 120, 200 |
| `difficulty` | `float` | 难度系数（平地=1.0，楼梯/斜坡>1.0） | 1.0, 1.2 |
| `capacity` | `Optional[int]` | 最大同时容纳人数（`None`=无限制） | 1, 10, None |
| `current_students` | `List[str]` | 当前正在此路径上的学生ID列表 | ["CS1-001", "MATH-042"] |

---

## 2. 成本计算公式

### 2.1 `get_travel_time()` 方法

**文件位置**: `src/campus/graph.py` (第 49-52 行)

```python
def get_travel_time(self, base_speed: float = 80.0) -> float:
    """Calculate travel time (minutes) for this path."""
    
    return (self.length * self.difficulty) / base_speed
```

#### 公式解析

$$
\text{Travel Time (minutes)} = \frac{\text{length (meters)} \times \text{difficulty}}{\text{base\_speed (m/min)}}
$$

#### 参数说明

- **`base_speed`**: 基准步行速度，默认 **80 米/分钟** (约 4.8 公里/小时)
- **`length`**: 路径的实际距离（米）
- **`difficulty`**: 
  - `1.0` = 平地（正常速度）
  - `1.2` = 有楼梯/斜坡（速度降低 20%）
  - `1.5` = 更陡峭的路径

#### 计算示例

| 场景 | length | difficulty | base_speed | Travel Time |
|------|--------|------------|------------|-------------|
| 平地 80 米 | 80 | 1.0 | 80 | **1.0 分钟** |
| 平地 200 米 | 200 | 1.0 | 80 | **2.5 分钟** |
| 楼梯 120 米 | 120 | 1.2 | 80 | **1.8 分钟** |
| 陡坡 100 米 | 100 | 1.5 | 80 | **1.875 分钟** |

---

## 3. Dijkstra 最短路径算法中的应用

### 3.1 `find_shortest_path()` 方法

**文件位置**: `src/campus/graph.py` (第 101-142 行)

```python
def find_shortest_path(self, start_id: str, end_id: str) -> Tuple[float, List[Building]]:
    """Run Dijkstra to find the lowest travel-time route."""
    
    distances: Dict[str, float] = {start_id: 0.0}
    previous: Dict[str, str] = {}
    heap: List[Tuple[float, str]] = [(0.0, start_id)]
    visited: set[str] = set()

    while heap:
        current_time, current_id = heappop(heap)
        if current_id in visited:
            continue
        visited.add(current_id)

        if current_id == end_id:
            break

        current_building = self.buildings[current_id]
        for path in current_building.paths:
            if not path.has_capacity():  # 🔴 检查容量限制
                continue
            neighbor_id = path.end.building_id
            if neighbor_id in visited:
                continue

            new_time = current_time + path.get_travel_time()  # 🔴 核心：累加旅行时间
            if new_time < distances.get(neighbor_id, inf):
                distances[neighbor_id] = new_time
                previous[neighbor_id] = current_id
                heappush(heap, (new_time, neighbor_id))

    if end_id not in distances:
        raise ValueError(f"No path found from {start_id} to {end_id}")

    return distances[end_id], self._reconstruct_route(previous, start_id, end_id)
```

#### 关键点

1. **权重 = 旅行时间**: 
   ```python
   new_time = current_time + path.get_travel_time()
   ```
   每条边的权重就是通过 `get_travel_time()` 计算的旅行时间。

2. **容量约束**: 
   ```python
   if not path.has_capacity():
       continue
   ```
   如果路径已满（`capacity` 达到上限），则该边在本次路径规划中被忽略。

3. **优先队列**: 
   使用 Python 的 `heapq`，始终选择当前累计成本最小的节点扩展。

---

## 4. 实际地图中的路径定义

### 4.1 地图路径数据

**文件位置**: `src/campus/data.py` (第 69+ 行)

```python
paths_data = [
    # 格式: (起点, 终点, 长度(米), 难度, 容量)
    
    # === 北部教学区 (平地) ===
    ("D3a", "D3b", 80, 1.0, None),      # 教学楼 D 横向连接（80米，无容量限制）
    ("D3b", "D3c", 80, 1.0, None),
    
    # === 连接图书馆（中等距离） ===
    ("D3d", "library", 120, 1.0, None), # 120米到图书馆
    
    # === 连接桥梁（跨区域） ===
    ("D3a", "bridge_west", 150, 1.0, None),
    ("library", "bridge_mid_left", 150, 1.0, None),
    
    # === 南部生活区 ===
    ("canteen", "gym", 200, 1.0, None),
    ("gym", "playground", 80, 1.0, None),
    
    # === 示例：有容量限制的路径 ===
    # ("A", "C", 60, 1.0, 1)  # 容量=1（仅允许1人同时通过）
]
```

#### 路径统计

| 距离范围 | 数量 | 说明 | 平均旅行时间 |
|---------|------|------|--------------|
| 80 米 | 12 条 | 相邻建筑 | **1.0 分钟** |
| 120-180 米 | 10 条 | 区域内连接 | **1.5-2.25 分钟** |
| 200-250 米 | 4 条 | 跨区域连接 | **2.5-3.1 分钟** |

---

## 5. 学生移动中的成本使用

### 5.1 学生路径规划

**文件位置**: `src/campus/student.py` (第 44-71 行)

```python
def plan_next_move(self, current_time: str, graph: Graph) -> Optional[ScheduleEvent]:
    """Plan a route towards the next scheduled event."""
    
    next_event = self.schedule.get_next_event(current_time)
    if next_event is None:
        return None

    target = graph.get_building(next_event.building_id)
    
    # 🔴 调用 Dijkstra 算法计算最短路径
    total_time, route = graph.find_shortest_path(
        self.current_location.building_id, 
        target.building_id
    )
    
    # 将路径分解为多个 _Segment（每个 segment 对应一条 Path）
    segments: List[_Segment] = []
    for start, end in zip(route, route[1:]):
        path = graph.get_path(start.building_id, end.building_id)
        segments.append(_Segment(
            path=path, 
            remaining_time=path.get_travel_time()  # 🔴 初始化剩余时间
        ))
    
    self.state = "moving"
    self.path_to_destination = route
    self._segments = segments
    return next_event
```

### 5.2 `_Segment` 类（路径分段）

**文件位置**: `src/campus/student.py` (第 11-30 行)

```python
@dataclass
class _Segment:
    """Represents progress travelling along a path."""
    
    path: Path           # 当前路径
    remaining_time: float  # 剩余旅行时间（初始值 = path.get_travel_time()）
    started: bool = False  # 是否已开始（用于容量占用）

    def step(self, student_id: str, delta_time: float) -> float:
        """Advance along the path and return leftover time."""
        
        if not self.started:
            if not self.path.has_capacity():
                raise RuntimeError("Path capacity exceeded")
            self.path.current_students.append(student_id)  # 占用容量
            self.started = True

        if delta_time < self.remaining_time:
            self.remaining_time -= delta_time  # 减少剩余时间
            return 0.0

        # 完成当前路径，返回多余的时间
        delta_time -= self.remaining_time
        self.remaining_time = 0.0
        if student_id in self.path.current_students:
            self.path.current_students.remove(student_id)  # 释放容量
        return delta_time
```

---

## 6. 测试案例

### 6.1 基本路径成本测试

**文件位置**: `src/tests/test_graph.py` (第 19-23 行)

```python
def test_shortest_path_prefers_lower_time(self) -> None:
    total_time, route = self.graph.find_shortest_path("A", "C")
    names = [building.name for building in route]
    self.assertEqual(names, ["Gate", "Library", "Cafeteria"])
    self.assertAlmostEqual(total_time, (80 + 40) / 80.0)  # (120米) / (80米/分钟) = 1.5分钟
```

### 6.2 容量限制测试

**文件位置**: `src/tests/test_graph.py` (第 25-29 行)

```python
def test_capacity_restrictions_block_edges(self) -> None:
    direct = self.graph.connect_buildings("A", "C", length=50, difficulty=1.0, capacity=1)
    direct.current_students.append("student-1")  # 占用唯一容量
    
    total_time, route = self.graph.find_shortest_path("A", "C")
    self.assertGreater(total_time, direct.get_travel_time())  # 被迫绕路，时间更长
    self.assertNotIn("Cafeteria", [building.name for building in route[:2]])
```

---

## 7. 影响路径成本的因素总结

| 因素 | 影响方式 | 实现位置 |
|------|---------|----------|
| **物理距离** (`length`) | 直接正比：距离越长，成本越高 | `Path.length` |
| **路径难度** (`difficulty`) | 系数乘法：难度越大，速度越慢 | `Path.difficulty` |
| **基准速度** (`base_speed`) | 分母：速度越快，成本越低 | `Path.get_travel_time()` |
| **容量限制** (`capacity`) | 布尔约束：满员时此路径不可用 | `Path.has_capacity()` |
| **当前使用者** (`current_students`) | 决定容量是否饱和 | `Path.current_students` |

---

## 8. 实际应用场景

### 8.1 早高峰场景（07:30-08:00）

- 大量学生从宿舍 → 食堂 → 教学楼
- 桥梁成为瓶颈（所有南北移动必须经过 4 座桥）
- 如果桥设置容量限制，后续学生将被迫选择更远的桥
- **成本**: 原路径 2 分钟，绕路可能变成 3.5 分钟

### 8.2 路径选择示例

假设学生在 D5a（宿舍），目标是 D3a（教室）：

**选项1：西桥**
```
D5a → bridge_west → D3a
路径: 150m + 150m = 300m
成本: 300 / 80 = 3.75 分钟
```

**选项2：中左桥**
```
D5a → gym → bridge_mid_left → D3d → D3c → D3b → D3a
路径: 180m + 150m + 80m + 80m + 80m = 570m
成本: 570 / 80 = 7.125 分钟
```

Dijkstra 算法会选择 **选项1**（更短时间）。

但如果 `bridge_west` 容量已满，系统会自动选择 **选项2**。

---

## 9. 扩展可能性

### 9.1 动态成本

- **时间因素**: 不同时段路径拥堵程度不同
  ```python
  def get_travel_time(self, base_speed: float = 80.0, time_of_day: str = "08:00") -> float:
      congestion_factor = 1.2 if time_of_day in PEAK_HOURS else 1.0
      return (self.length * self.difficulty * congestion_factor) / base_speed
  ```

### 9.2 个性化成本

- **不同学生速度**: 运动员步行更快，残疾学生需要避开楼梯
  ```python
  class Student:
      walking_speed: float = 80.0  # 默认80，运动员可能是90
      avoid_stairs: bool = False    # 残疾学生为True
  ```

### 9.3 环境因素

- **天气影响**: 雨天户外路径成本提高
- **建筑维护**: 某些路径临时关闭

---

## 10. 总结

### 核心公式

$$
\text{Cost} = \frac{\text{Length} \times \text{Difficulty}}{\text{BaseSpeed}}
$$

### 关键文件

| 文件 | 关键类/函数 | 作用 |
|------|------------|------|
| `src/campus/graph.py` | `Path.get_travel_time()` | **计算单条路径成本** |
| `src/campus/graph.py` | `Graph.find_shortest_path()` | **Dijkstra 最短路径** |
| `src/campus/student.py` | `Student.plan_next_move()` | 调用算法规划路径 |
| `src/campus/student.py` | `_Segment.step()` | 按成本推进移动 |
| `src/campus/data.py` | `create_campus_map()` | 定义所有路径参数 |

### 数据流向

```
定义路径 (data.py)
    ↓
Path.get_travel_time() 计算成本
    ↓
Graph.find_shortest_path() 使用成本运行 Dijkstra
    ↓
Student.plan_next_move() 获取最优路径
    ↓
_Segment.step() 按成本推进学生移动
```

---

**文档版本**: 1.0  
**创建日期**: 2025-10-22  
**作者**: AI Assistant  
**项目**: Campus Life Simulation
